# Rendering a collection, modules
## Key attribute
React uses the key attributes of objects in an array to determine how to update the view generated by a component when the component is re-rendered. That is why we put `key={note.id}` so that the error in the console disappears.

## Anti-pattern: Array Indexes as Keys
We could have made the error message on our console disappear by using the array indexes as keys. The indexes can be retrieved by passing a second parameter to the callback function of the `map` method:

```js
notes.map((note, i) => ...)
```

When called like this, i is assigned the value of the index of the position in the array where the note resides.

```js
<ul>
  {notes.map((note, i) => 
    <li key={i}>
      {note.content}
    </li>
  )}
</ul>
```
This is; however, not recommended and can create undesired problems even if it seems to be working just fine.

# Forms

```js
const App = (props) => {
const [notes, setNotes] = useState(props.notes)
```
The component uses the `useState` function to initialize the piece of state stored in `notes` with the array of notes passed in the props:

We have added the `addNote` function as an event handler to the form element that will be called when the form is submitted, by clicking the submit button.

The `event` parameter is the event that triggers the call to the event handler function:

The event handler immediately calls the `event.preventDefault()` method, which prevents the default action of submitting a form. The default action would, among other things, cause the page to reload.
```js
const addNote = (event) => {
  event.preventDefault()
  onsole.log('button clicked', event.target)
}
```
In order to enable editing of the input element, we have to register an event handler that synchronizes the changes made to the input with the component's state:

```js
  const handleNoteChange = (event) => {
  console.log(event.target.value)
  setNewNote(event.target.value)
 }
```
We have now registered an event handler to the onChange attribute of the form's input element:

```js
<input
  value={newNote}
  onChange={handleNoteChange}
/>
```

The `target` property of the event object now corresponds to the controlled input element and `event.target.value` refers to the input value of that element.


# Getting data from server
7
Install JSON server globally: `npm install -g json-server`

A global installation is not necessary. From the root directory of the app, we can run the json-server using the command npx: `npx json-server --port 3001 --watch db.json`

Going forward, the idea will be to save the notes to the server, which in this case means saving to the json-server. The React code fetches the notes from the server and renders them to the screen. Whenever a new note is added to the application the React code also sends it to the server to make the new note persist in "memory".

## npm

We will use the promise based function [fetch](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch) to pull the data from the server. Fetch is a great tool. It is standardized and supported by all modern browsers.

We will be using the `axios` library instead for communication between the browser and server. It functions like fetch, but is somewhat more pleasant to use. Another good reason to use axios is our getting familiar with adding external libraries, so-called npm packages, to React projects.

**npm-commands should always be run in the project root directory**, which is where the package.json file can be found.

 Install json-server as a development dependency (only used during development) by executing the command:
 `npm install json-server --save-dev`

Make a small addition to the scripts part of the package.json file:
![image](https://i.imgur.com/VpjURWr.png)

We can now conveniently, without parameter definitions, start the json-server from the project root directory with the command:

`npm run server`

The command npm install was used twice, but with slight differences:

```
npm install axios
npm install json-server --save-dev
```
There is a fine difference in the parameters. axios is installed as a runtime dependency of the application, because the execution of the program requires the existence of the library. On the other hand, json-server was installed as a development dependency (--save-dev), since the program itself doesn't require it.

## Axios and promises

The library can be brought into use the same way other libraries, e.g. React, are, i.e. by using an appropriate import statement.

**Note:** when the content of the file index.js changes, React does not notice that automatically so you must refresh the browser to see your changes! A simple workaround to make React notice the change automatically, is to create a file named .env in the root directory of the project and add this line `FAST_REFRESH=false`. Restart the app for the applied changes to take effect.

A **Promise** is an object representing the eventual completion or failure of an asynchronous operation.

In other words, a promise is an object that represents an asynchronous operation. A promise can have three distinct states:

1. **The promise is pending:** It means that the final value (one of the following two) is not available yet.
2. **The promise is fulfilled:** It means that the operation has completed and the final value is available, which generally is a successful operation. This state is sometimes also called resolved.
3. **The promise is rejected:** It means that an error prevented the final value from being determined, which generally represents a failed operation.

![image](https://imgur.com/WIHTgoE)

If we open http://localhost:3000 in the browser, we see this in console

The first promise in our example is fulfilled, representing a successful `axios.get('http://localhost:3001/notes')` request. The second one, however, is rejected, and the console tells us the reason. It looks like we were trying to make an HTTP GET request to a non-existent address.

If, and when, we want to access the result of the operation represented by the promise, we must register an event handler to the promise. This is achieved using the method then:

```js
const promise = axios.get('http://localhost:3001/notes')

promise.then(response => {
  console.log(response)
})
```
The following is printed in the console:
![image](https://i.imgur.com/GGPuqnl.png)

The JavaScript runtime environment calls the callback function registered by the `then` method providing it with a `response` object as a parameter. The `response` object contains all the essential data related to the response of an HTTP GET request, which would include the returned *data*, *status code*, and *headers*.

```js
axios
  .get('http://localhost:3001/notes')
  .then(response => {
    const notes = response.data
    console.log(notes)
  })
```
The callback function now takes the data contained within the response, stores it in a variable and prints the notes to the console.

The data returned by the server is plain text, basically just one long string. The axios library is still able to parse the data into a JavaScript array, since the server has specified that the data format is application/json; charset=utf-8 (see previous image) using the content-type header.

We can finally begin using the data fetched from the server.

```js
import React from 'react'
import ReactDOM from 'react-dom'
import App from './App'

import axios from 'axios'

axios.get('http://localhost:3001/notes').then(response => {
  const notes = response.data
  ReactDOM.render(
    <App notes={notes} />,
    document.getElementById('root')
  )
})
```
This method could be acceptable in some circumstances, but it's somewhat problematic. Let's instead move the fetching of the data into the App component.


