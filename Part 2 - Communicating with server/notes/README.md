# Rendering a collection, modules
## Key attribute
React uses the key attributes of objects in an array to determine how to update the view generated by a component when the component is re-rendered. That is why we put `key={note.id}` so that the error in the console disappears.

## Anti-pattern: Array Indexes as Keys
We could have made the error message on our console disappear by using the array indexes as keys. The indexes can be retrieved by passing a second parameter to the callback function of the `map` method:

```js
notes.map((note, i) => ...)
```

When called like this, i is assigned the value of the index of the position in the array where the note resides.

```js
<ul>
  {notes.map((note, i) => 
    <li key={i}>
      {note.content}
    </li>
  )}
</ul>
```
This is; however, not recommended and can create undesired problems even if it seems to be working just fine.

# Forms

```js
const App = (props) => {
const [notes, setNotes] = useState(props.notes)
```
The component uses the `useState` function to initialize the piece of state stored in `notes` with the array of notes passed in the props:

We have added the `addNote` function as an event handler to the form element that will be called when the form is submitted, by clicking the submit button.

The `event` parameter is the event that triggers the call to the event handler function:

The event handler immediately calls the `event.preventDefault()` method, which prevents the default action of submitting a form. The default action would, among other things, cause the page to reload.
```js
const addNote = (event) => {
  event.preventDefault()
  onsole.log('button clicked', event.target)
}
```
In order to enable editing of the input element, we have to register an event handler that synchronizes the changes made to the input with the component's state:

```js
  const handleNoteChange = (event) => {
  console.log(event.target.value)
  setNewNote(event.target.value)
 }
```
We have now registered an event handler to the onChange attribute of the form's input element:

```js
<input
  value={newNote}
  onChange={handleNoteChange}
/>
```

The `target` property of the event object now corresponds to the controlled input element and `event.target.value` refers to the input value of that element.


# Getting data from server

Install JSON server globally: `npm install -g json-server`

A global installation is not necessary. From the root directory of the app, we can run the json-server using the command npx: `npx json-server --port 3001 --watch db.json`

Going forward, the idea will be to save the notes to the server, which in this case means saving to the json-server. The React code fetches the notes from the server and renders them to the screen. Whenever a new note is added to the application the React code also sends it to the server to make the new note persist in "memory".

## npm

We will use the promise based function [fetch](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch) to pull the data from the server. Fetch is a great tool. It is standardized and supported by all modern browsers.

We will be using the `axios` library instead for communication between the browser and server. It functions like fetch, but is somewhat more pleasant to use. Another good reason to use axios is our getting familiar with adding external libraries, so-called npm packages, to React projects.

**npm-commands should always be run in the project root directory**, which is where the package.json file can be found.

 Install json-server as a development dependency (only used during development) by executing the command:
 `npm install json-server --save-dev`

Make a small addition to the scripts part of the package.json file:
![image](https://i.imgur.com/VpjURWr.png)

We can now conveniently, without parameter definitions, start the json-server from the project root directory with the command:

`npm run server`

The command npm install was used twice, but with slight differences:

```
npm install axios
npm install json-server --save-dev
```
There is a fine difference in the parameters. axios is installed as a runtime dependency of the application, because the execution of the program requires the existence of the library. On the other hand, json-server was installed as a development dependency (--save-dev), since the program itself doesn't require it.

## Axios and promises

The library can be brought into use the same way other libraries, e.g. React, are, i.e. by using an appropriate import statement.

**Note:** when the content of the file index.js changes, React does not notice that automatically so you must refresh the browser to see your changes! A simple workaround to make React notice the change automatically, is to create a file named .env in the root directory of the project and add this line `FAST_REFRESH=false`. Restart the app for the applied changes to take effect.

A **Promise** is an object representing the eventual completion or failure of an asynchronous operation.

In other words, a promise is an object that represents an asynchronous operation. A promise can have three distinct states:

1. **The promise is pending:** It means that the final value (one of the following two) is not available yet.
2. **The promise is fulfilled:** It means that the operation has completed and the final value is available, which generally is a successful operation. This state is sometimes also called resolved.
3. **The promise is rejected:** It means that an error prevented the final value from being determined, which generally represents a failed operation.

![image](https://imgur.com/WIHTgoE)

If we open http://localhost:3000 in the browser, we see this in console

The first promise in our example is fulfilled, representing a successful `axios.get('http://localhost:3001/notes')` request. The second one, however, is rejected, and the console tells us the reason. It looks like we were trying to make an HTTP GET request to a non-existent address.

If, and when, we want to access the result of the operation represented by the promise, we must register an event handler to the promise. This is achieved using the method then:

```js
const promise = axios.get('http://localhost:3001/notes')

promise.then(response => {
  console.log(response)
})
```
The following is printed in the console:
![image](https://i.imgur.com/GGPuqnl.png)

The JavaScript runtime environment calls the callback function registered by the `then` method providing it with a `response` object as a parameter. The `response` object contains all the essential data related to the response of an HTTP GET request, which would include the returned *data*, *status code*, and *headers*.

```js
axios
  .get('http://localhost:3001/notes')
  .then(response => {
    const notes = response.data
    console.log(notes)
  })
```
The callback function now takes the data contained within the response, stores it in a variable and prints the notes to the console.

The data returned by the server is plain text, basically just one long string. The axios library is still able to parse the data into a JavaScript array, since the server has specified that the data format is application/json; charset=utf-8 (see previous image) using the content-type header.

We can finally begin using the data fetched from the server.

```js
import React from 'react'
import ReactDOM from 'react-dom'
import App from './App'

import axios from 'axios'

axios.get('http://localhost:3001/notes').then(response => {
  const notes = response.data
  ReactDOM.render(
    <App notes={notes} />,
    document.getElementById('root')
  )
})
```
This method could be acceptable in some circumstances, but it's somewhat problematic. Let's instead move the fetching of the data into the App component.



## Effect-hooks

The Effect Hook lets you perform side effects in function components. Data fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects.

Effect hooks are precisely the right tool to use when fetching data from a server.

After changing the app component:
```js
  useEffect(() => {
    console.log('effect')
    axios
      .get('http://localhost:3001/notes')
      .then(response => {
        console.log('promise fulfilled')
        setNotes(response.data)
      })
  }, [])
  ```
This is printed to the console
```
render 0 notes
effect
promise fulfilled
render 3 note
```
First the body of the function defining the component is executed and the component is rendered for the first time. At this point render 0 notes is printed, meaning data hasn't been fetched from the server yet.

```js
() => {
  console.log('effect')
  axios
    .get('http://localhost:3001/notes')
    .then(response => {
      console.log('promise fulfilled')
      setNotes(response.data)
    })
}
```
This is executed immediately after rendering. The execution of the function results in effect being printed to the console, and the command axios.get initiates the fetching of data from the server as well as registers the following function as an event handler for the operation:

```js
response => {
  console.log('promise fulfilled')
  setNotes(response.data)
})
```

When data arrives from the server, the JavaScript runtime calls the function registered as the event handler, which prints promise fulfilled to the console and stores the notes received from the server into the state using the function `setNotes(response.data)`.

As always, a call to a state-updating function triggers the re-rendering of the component. As a result, render 3 notes is printed to the console, and the notes fetched from the server are rendered to the screen.

```js
const hook = () => {
  console.log('effect')
  axios
    .get('http://localhost:3001/notes')
    .then(response => {
      console.log('promise fulfilled')
      setNotes(response.data)
    })
}

useEffect(hook, [])
```
Now we can see more clearly that the function useEffect actually takes two parameters. The first is a function, the effect itself. According to the documentation:

*By default, effects run after every completed render, but you can choose to fire it only when certain values have changed.*
So by default the effect is always run after the component has been rendered. In our case, however, we only want to execute the effect along with the first render.

The second parameter of useEffect is used to [specify how often the effect is run](https://reactjs.org/docs/hooks-reference.html#conditionally-firing-an-effect). If the second parameter is an empty array [], then the effect is only run along with the first render of the component.

Note that we could have also written the code of the effect function this way:

```js
useEffect(() => {
  console.log('effect')

  const eventHandler = response => {
    console.log('promise fulfilled')
    setNotes(response.data)
  }

  const promise = axios.get('http://localhost:3001/notes')
  promise.then(eventHandler)
}, [])
```
1. A reference to an event handler function is assigned to the variable eventHandler. 
2. The promise returned by the get method of Axios is stored in the variable promise. 
3. The registration of the callback happens by giving the eventHandler variable, referring to the event-handler function, as a parameter to the then method of the promise. 

It isn't usually necessary to assign functions and promises to variables, and a more compact way of representing things, as seen further above, is sufficient.

## The development runtime environment

![image](https://i.imgur.com/V6cs8CW.png)

1. The JavaScript code making up our React application is run in the browser. 
2. The browser gets the JavaScript from the React dev server, which is the application that runs after running the command npm start.
3. The dev-server transforms the JavaScript into a format understood by the browser. Among other things, it stitches together JavaScript from different files into one file.

4. The React application running in the browser fetches the JSON formatted data from json-server running on port 3001 on the machine.
5. The server we query the data from - json-server - gets its data from the file db.json.

# Altering data in server

When creating notes in our application, we would naturally want to store them in some backend server. The [json-server](https://github.com/typicode/json-server) package claims to be a so-called REST or RESTful API in its documentation:

*Get a full fake REST API with zero coding in less than 30 seconds (seriously)*

The json-server does not exactly match the description provided by the textbook [definition](https://en.wikipedia.org/wiki/Representational_state_transfer) of a REST API, but neither do most other APIs claiming to be RESTful.

## REST

In REST terminology, we refer to individual data objects, such as the notes in our application, as *resources*. Every resource has a unique address associated with it - its URL. According to a general convention used by json-server, we would be able to locate an individual note at the resource URL notes/3, where 3 is the id of the resource. The notes url, on the other hand, would point to a resource collection containing all the notes.

Resources are fetched from the server with HTTP GET requests. For instance, an HTTP GET request to the URL *notes/3* will return the note that has the id number 3. An HTTP GET request to the *notes* URL would return a list of all notes.

Creating a new resource for storing a note is done by making an HTTP POST request to the **notes* URL according to the REST convention that the json-server adheres to. The data for the new note resource is sent in the **body* of the request.

json-server requires all data to be sent in JSON format. What this means in practice is that the data must be a correctly formatted string, and that the request must contain the *Content-Type* request header with the value *application/json*.

## Sending Data to the Server
Let's make the following changes to the event handler responsible for creating a new note:

```js
addNote = event => {
  event.preventDefault()
  const noteObject = {
    content: newNote,
    date: new Date(),
    important: Math.random() < 0.5,
  }

  axios
    .post('http://localhost:3001/notes', noteObject)
    .then(response => {
      console.log(response)
    })
}
```

```js
axios
  .post('http://localhost:3001/notes', noteObject)
  .then(response => {
    console.log(response)
  })
```
We create a new object for the note but omit the id property, since it's better to let the server generate ids for our resources!

The object is sent to the server using the axios post method. The registered event handler logs the response that is sent back from the server to the console.

The newly created note resource is stored in the value of the data property of the response object.

![image](https://i.imgur.com/YYlbUu8.png)

Since the data we sent in the POST request was a JavaScript object, axios automatically knew to set the appropriate *application/json* value for the Content-Type header.

The new note is not rendered to the screen yet. This is because we did not update the state of the App component when we created the new note. Let's fix this:

```js
axios
  .post('http://localhost:3001/notes', noteObject)
  .then(response => {
    setNotes(notes.concat(response.data))
    setNewNote('')
  })
```
The new note returned by the backend server is added to the list of notes in our application's state in the customary way of using the setNotes function and then resetting the note creation form. An important detail to remember is that the concat method does not change the component's original state, but instead creates a new copy of the list.

![image](https://i.imgur.com/aWSjLkN.png)

This makes it possible to verify that all the data we intended to send was actually received by the server.

## Changing the Importance of Notes

```js
const Note = ({ note, toggleImportance }) => {
  const label = note.important
    ? 'make not important' : 'make important'

  return (
    <li>
      {note.content} 
      <button onClick={toggleImportance}>{label}</button>
    </li>
  )
}
```
We add a button to the component and assign its event handler as the toggleImportance function passed in the component's props.

The App component defines an initial version of the toggleImportanceOf event handler function and passes it to every Note component:

![image](https://i.imgur.com/T6Qesj3.png)

Notice how every note receives its own unique event handler function, since the id of every note is unique.

E.g. if note.id is 3, the event handler function returned by toggleImportance(note.id) will be:

```js
() => { console.log('importance of 3 needs to be toggled') }
```

Individual notes stored in the json-server backend can be modified in two different ways by making HTTP requests to the note's unique URL. We can either replace the entire note with an HTTP PUT request, or only change some of the note's properties with an HTTP PATCH request.

The final form of the event handler function is the following:

```js
const toggleImportanceOf = id => {
  const url = `http://localhost:3001/notes/${id}`
  const note = notes.find(n => n.id === id)
  const changedNote = { ...note, important: !note.important }

  axios.put(url, changedNote).then(response => {
    setNotes(notes.map(note => note.id !== id ? note : response.data))
  })
}
```
The first line defines the unique url for each note resource based on its id.

The array [find method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find) is used to find the note we want to modify, and we then assign it to the note variable.

After this we create a new object that is an exact copy of the old note, apart from the important property.

The code for creating the new object that uses the [object spread](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax) syntax may seem a bit strange at first:

```js
const changedNote = { ...note, important: !note.important }
```
In practice `{ ...note }`creates a new object with copies of all the properties from the `note` object. When we add properties inside the curly braces after the spreaded object, e.g. `{ ...note, important: true }`, then the value of the `important` property of the new object will be `true`. In our example the `important` property gets the negation of its previous value in the original object.

There's a few things to point out. Why did we make a copy of the note object we wanted to modify, when the following code also appears to work?

```js
const note = notes.find(n => n.id === id)
note.important = !note.important

axios.put(url, note).then(response => {
  // ...
```
This is not recommended because the variable `note` is a reference to an item in the `notes` array in the component's state, and as we recall we must never mutate state directly in React.

It's also worth noting that the new object `changedNote` is only a so-called [shallow copy](https://en.wikipedia.org/wiki/Object_copying#Shallow_copy), meaning that the values of the new object are the same as the values of the old object. If the values of the old object were objects themselves, then the copied values in new object would reference the same objects that were in the old object.

The new note is then sent with a PUT request to the backend where it will replace the old object.

The callback function sets the component's notes state to a new array that contains all the items from the previous notes array, except for the old note which is replaced by the updated version of it returned by the server:

```js
axios.put(url, changedNote).then(response => {
  setNotes(notes.map(note => note.id !== id ? note : response.data))
})
```
The map method creates a new array by mapping every item from the old array into an item in the new array. In our example, the new array is created conditionally so that if `note.id !== id` is true, we simply copy the item from the old array into the new array. If the condition is false, then the note object returned by the server is added to the array instead.


## Extracting Communication with the Backend into a Separate Module

The App component has become somewhat bloated after adding the code for communicating with the backend server. In the spirit of the [single responsibility principle](https://en.wikipedia.org/wiki/Single-responsibility_principle), we deem it wise to extract this communication into its own module.

Let's create a src/services directory and add a file there called notes.js.
```js
import axios from 'axios'
const baseUrl = 'http://localhost:3001/notes'

const getAll = () => {
  return axios.get(baseUrl)
}

const create = newObject => {
  return axios.post(baseUrl, newObject)
}

const update = (id, newObject) => {
  return axios.put(`${baseUrl}/${id}`, newObject)
}

export default { 
  getAll: getAll, 
  create: create, 
  update: update 
}
```

The module returns an object that has three functions (getAll, create, and update) as its properties that deal with notes. The functions directly return the promises returned by the axios methods.

The functions of the module can be used directly with the imported variable `noteService` as follows:

![image](https://i.imgur.com/mjrPqDl.png)

We could take our implementation a step further. When the App component uses the functions, it receives an object that contains the entire response for the HTTP request:

```js
noteService
  .getAll()
  .then(response => {
    setNotes(response.data)
  })
```
The App component only uses the response.data property of the response object.

The module would be much nicer to use if, instead of the entire HTTP response, we would only get the response data. Using the module would then look like this:

```js
noteService
  .getAll()
  .then(initialNotes => {
    setNotes(initialNotes)
  })
```
We can achieve this by changing the code in the module as follows (the current code contains some copy-paste, but we will tolerate that for now):

```js
import axios from 'axios'
const baseUrl = 'http://localhost:3001/notes'

const getAll = () => {
  const request = axios.get(baseUrl)
  return request.then(response => response.data)
}

const create = newObject => {
  const request = axios.post(baseUrl, newObject)
  return request.then(response => response.data)
}

const update = (id, newObject) => {
  const request = axios.put(`${baseUrl}/${id}`, newObject)
  return request.then(response => response.data)
}

export default { 
  getAll: getAll, 
  create: create, 
  update: update 
}
```
We no longer return the promise returned by axios directly. Instead, we assign the promise to the request variable and call its then method:

```js
const getAll = () => {
  const request = axios.get(baseUrl)
  return request.then(response => response.data)
}
```
The modified `getAll` function still returns a promise, as the `then` method of a promise also returns a promise.

After defining the parameter of the `then` method to directly return response.data, we have gotten the `getAll` function to work like we wanted it to. When the HTTP request is successful, the promise returns the data sent back in the response from the backend.



